<!DOCTYPE html>
<html>
<head>
  <title>Audio Recorder</title>
</head>
<body>
  <h1>Audio Recorder</h1>

  <!-- Buttons for controlling the recording and trimming -->
  <button id="recordBtn">Record</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="saveBtn" disabled>Save</button>
  <button id="trimBtn" disabled>Trim</button>

  <!-- Display the elapsed recording time -->
  <span id="recordCounter">00:00</span>

  <h3>Original Audio</h3>
  <!-- Audio player to play the original recorded audio -->
  <audio id="audioPlayer" controls></audio>

  <!-- Trim controls, hidden until recording is complete -->
  <div id="trimControls" style="display: none;">
    <label for="startTrim">Start Trim (s):</label>
    <input type="number" id="startTrim" min="0" value="0">
    <label for="endTrim">End Trim (s):</label>
    <input type="number" id="endTrim" min="0" value="0">
    <button id="applyTrimBtn">Apply Trim</button>
  </div>

  <h3>Trimmed Audio</h3>
  <!-- Audio player to play the trimmed version -->
  <audio id="trimmedAudioPlayer" controls style="display:none;"></audio>

  <script>
    // Accessing all the HTML elements by their IDs
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const saveBtn = document.getElementById('saveBtn');
    const trimBtn = document.getElementById('trimBtn');
    const audioPlayer = document.getElementById('audioPlayer');
    const trimmedAudioPlayer = document.getElementById('trimmedAudioPlayer');
    const recordCounter = document.getElementById('recordCounter');
    const trimControls = document.getElementById('trimControls');
    const startTrimInput = document.getElementById('startTrim');
    const endTrimInput = document.getElementById('endTrim');
    const applyTrimBtn = document.getElementById('applyTrimBtn');

    let mediaRecorder; // MediaRecorder object to record audio
    let audioChunks = []; // Stores the chunks of audio data as it is being recorded
    let recordStartTime; // Timestamp when recording starts
    let recordingInterval; // Interval for updating the recording time counter
    let audioBlob; // The audio file created from the recorded chunks
    let trimmedBlob; // The final audio file after trimming
    let originalAudioBuffer; // The decoded audio buffer used for trimming

    // Request permission to use the microphone and access the audio stream
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        // Set up the media recorder to record from the microphone
        mediaRecorder = new MediaRecorder(stream);

        // Event when audio data is available
        mediaRecorder.addEventListener('dataavailable', event => {
          audioChunks.push(event.data); // Store the audio data chunk
        });

        // Event when the recording starts
        mediaRecorder.addEventListener('start', () => {
          recordStartTime = new Date().getTime(); // Set the start time
          recordingInterval = setInterval(updateRecordCounter, 1000); // Update the counter every second
        });

        // Event when the recording stops
        mediaRecorder.addEventListener('stop', () => {
          clearInterval(recordingInterval); // Stop updating the counter
          audioBlob = new Blob(audioChunks, { type: 'audio/wav' }); // Combine chunks into a single Blob
          audioPlayer.src = URL.createObjectURL(audioBlob); // Set the audio source to the Blob
          audioPlayer.controls = true; // Enable controls for the audio player
          audioChunks = []; // Clear the chunks array
          recordCounter.textContent = '00:00'; // Reset the time counter
          saveBtn.disabled = false; // Enable the save button
          trimBtn.disabled = false; // Enable the trim button
          trimControls.style.display = 'block'; // Show the trim controls

          // Decode the audio file into an audio buffer for trimming
          const reader = new FileReader();
          reader.onload = function () {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioContext.decodeAudioData(reader.result, (buffer) => {
              originalAudioBuffer = buffer; // Store the decoded audio buffer
              endTrimInput.value = buffer.duration; // Set the maximum possible trim time
            });
          };
          reader.readAsArrayBuffer(audioBlob); // Read the Blob as an array buffer
        });

        // Start recording when the record button is clicked
        recordBtn.addEventListener('click', () => {
          mediaRecorder.start(); // Start the media recorder
          recordBtn.disabled = true; // Disable the record button while recording
          stopBtn.disabled = false; // Enable the stop button
          saveBtn.disabled = true; // Disable the save button until the recording stops
          trimBtn.disabled = true; // Disable the trim button during recording
        });

        // Stop recording when the stop button is clicked
        stopBtn.addEventListener('click', () => {
          mediaRecorder.stop(); // Stop the media recorder
          recordBtn.disabled = false; // Enable the record button again
          stopBtn.disabled = true; // Disable the stop button after recording ends
        });

        // Save the recording as a WAV file when the save button is clicked
        saveBtn.addEventListener('click', () => {
          const downloadLink = document.createElement('a'); // Create a download link
          downloadLink.href = URL.createObjectURL(trimmedBlob || audioBlob); // Set the download link to the audio file (trimmed or original)
          downloadLink.download = 'recorded_audio.wav'; // Set the download file name
          document.body.appendChild(downloadLink); // Add the link to the document
          downloadLink.click(); // Trigger the download
          document.body.removeChild(downloadLink); // Remove the link from the document
        });

        // Display the trim controls when the trim button is clicked
        trimBtn.addEventListener('click', () => {
          startTrimInput.value = 0; // Set the start trim to 0 seconds
          endTrimInput.value = originalAudioBuffer ? originalAudioBuffer.duration : 0; // Set the max end trim to the audio duration
        });

        // Apply the trim when the "Apply Trim" button is clicked
        applyTrimBtn.addEventListener('click', () => {
          const startTrim = parseFloat(startTrimInput.value); // Get the start trim value
          const endTrim = parseFloat(endTrimInput.value); // Get the end trim value
          if (startTrim < 0 || endTrim <= startTrim || endTrim > originalAudioBuffer.duration) {
            alert('Invalid trim values'); // Alert if trim values are invalid
            return;
          }

          // Create an audio context to process the audio buffer
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const startSample = audioContext.sampleRate * startTrim; // Calculate start sample position
          const endSample = audioContext.sampleRate * endTrim; // Calculate end sample position

          // Create a new audio buffer to store the trimmed portion
          const trimmedBuffer = audioContext.createBuffer(
            originalAudioBuffer.numberOfChannels,
            endSample - startSample,
            originalAudioBuffer.sampleRate
          );

          // Copy the trimmed audio data into the new buffer
          for (let channel = 0; channel < originalAudioBuffer.numberOfChannels; channel++) {
            const channelData = originalAudioBuffer.getChannelData(channel);
            trimmedBuffer.copyToChannel(channelData.subarray(startSample, endSample), channel);
          }

          // Convert the trimmed buffer to a WAV file and set it as the source for the trimmed audio player
          trimmedBlob = bufferToWav(trimmedBuffer);
          trimmedAudioPlayer.src = URL.createObjectURL(trimmedBlob);
          trimmedAudioPlayer.style.display = 'block'; // Show the trimmed audio player
          alert('Trim applied successfully!'); // Show a success message
        });
      })
      .catch(error => {
        console.error('Error accessing microphone:', error); // Log any errors
      });

    // Function to update the recording time counter every second
    function updateRecordCounter() {
      const currentTime = new Date().getTime();
      const elapsedSeconds = Math.floor((currentTime - recordStartTime) / 1000); // Calculate elapsed time in seconds
      const minutes = Math.floor(elapsedSeconds / 60); // Calculate minutes
      const seconds = elapsedSeconds % 60; // Calculate seconds
      recordCounter.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; // Update the counter display
    }

    // Function to convert an audio buffer to WAV format
    function bufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16; // Standard bit depth for WAV format

      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;

      const bufferLength = buffer.length * numChannels * bytesPerSample;
      const wavBuffer = new ArrayBuffer(44 + bufferLength);
      const view = new DataView(wavBuffer);

      // Write WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + bufferLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true); // Subchunk1Size
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, bufferLength, true);

      // Write PCM samples
      let offset = 44;
      for (let channel = 0; channel < numChannels; channel++) {
        const channelData = buffer.getChannelData(channel);
        for (let i = 0; i < channelData.length; i++) {
          const sample = Math.max(-1, Math.min(1, channelData[i])); // Normalize the sample
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true); // Write the sample as PCM data
          offset += 2;
        }
      }

      return new Blob([new Uint8Array(wavBuffer)], { type: 'audio/wav' }); // Return the WAV file Blob
    }

    // Helper function to write a string to the DataView
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i)); // Write each character of the string
      }
    }
  </script>
</body>
</html>
